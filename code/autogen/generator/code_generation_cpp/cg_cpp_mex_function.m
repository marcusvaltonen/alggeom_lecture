function str = cg_cpp_mex_function(solv, template, opt, solve_name)
    indent = opt.cg_indentation;
    str = sprintf(['void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])\n'...
    '{\n'...
    'if (nrhs != 1) {\n'...
    indent 'mexErrMsgIdAndTxt("automatic_generator_cvpr:solver_%2$s:nrhs", "One input required.");\n'...
    '}\n'...
    'if (nlhs != 1) {\n'...
    indent 'mexErrMsgIdAndTxt("automatic_generator_cvpr:solver_%2$s:nlhs", "One output required.");\n'...
    '}    \n'...
    'if (!mxIsDouble(prhs[0]) || mxIsComplex(prhs[0])) {\n'...
    indent 'mexErrMsgIdAndTxt("automatic_generator_cvpr:solver_%2$s:notDouble", "Input data must be type double.");\n'...
    '}\n'...
    'if(mxGetNumberOfElements(prhs[0]) != %1$d) {\n'...
    indent 'mexErrMsgIdAndTxt("automatic_generator_cvpr:solver_%2$s:incorrectSize", "Input size must be %1$d.");\n'...
    '}\n'...
    'const VectorXd data = Map<const VectorXd>(mxGetPr(prhs[0]),%1$d);\n'...
    'MatrixXcd sols = solver_%2$s(data);\n'...
    'plhs[0] = mxCreateDoubleMatrix(sols.rows(),sols.cols(),mxCOMPLEX);\n'...
    'double* zr = mxGetPr(plhs[0]);\n'...
    'double* zi = mxGetPi(plhs[0]);\n'...
    'for (Index i = 0; i < sols.size(); i++) {\n'...
    indent 'zr[i] = sols(i).real();\n'...
    indent 'zi[i] = sols(i).imag();\n'...
    '}\n'...
    '}\n'],nvars(solv.coefficients.coeff_eqs(1)),solve_name);
end

